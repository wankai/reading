# 导言

## 1.1 介绍

函数式编程是一种以函数为基本构件的程序设计方法。它既是解决实际问题的强有力的方法学，也是研究可计算性理论的工具。因此，函数式编程可以在理论和实践之间架起桥梁，让我们用形式化的理论去研究实际问题。

本章将涉及：

* 函数式编程和传统的命令式编程的区别
* 函数式编程的起源，以及它与现代可计算性理论的关系
* 函数式编程的基础 — λ演算

## 1.2 编程中的名与值

为了理解名与值，我们用计算器举例。平面上有一个点(3, 4)，我们要用计算器算出它到原点的距离。勾股定理大家都知道，于是根据公式在计算器上敲出来。又有一个点(5, 12)，也要算它到原点的距离，于是又敲一遍。每碰到一个新的点，我们都要根据勾股定理重新敲一遍计算器。

但是在计算机上，我们可不是这样算距离的。我们写好勾股定理的程序后，要计算一个点到原点的距离，只需要把坐标值输入就可以了。程序可能如下：
``` python
x <- input
y <- input
distance = sqrt(x * x + y * y)
print distance
```
相比于计算器，计算机程序能节省大量的点击操作，其中关键就是程序可以用符号来代替具体的数。一经引入符号，就解决了所有的“求某个点到原点的距离”的问题，太强大了。

符号就是名。编写程序的时候，用名替换具体的值；执行程序的时候，用具体的值替换名。

我们将发现，命令式语言（如Pascal, Fortran, Cobol）和函数式语言（如SML，Miranda）的主要区别就是如何处理名与值的关系。

## 1.3 命令式语言和函数式语言中的名与值

命令式语言的根基是名与值的可变绑定，即__变量__。它们之所以被称为“命令式”，是因为他们的程序由一串命令组成。

\<command1>; \<command2>; \<command3>; ......

通常，每一条命令都有赋值操作，对右边表达式的求值，然后赋值给左边的变量。

\<name> := \<expression>

在一段程序中，每一条命令都会引用一些被前面的命令赋值过的变量，于是变量的值就能在一串命令中传递。


函数式语言的根基是函数调用，一个函数式语言编写的程序就是一个不断嵌套调用的函数：

\<function1>(\<function2> (\<function3> \<function4> ...) ...))

每个函数以别的函数为参数，求出的值又作为调用函数的参数，如此形成函数的组合或嵌套。

在命令式语言中，已经绑定某值的名，可能会随着命令的执行绑定新值。在函数式语言中，名通过形参引入，求值时绑定实参，一旦绑定永不更改。所以函数式语言中没有赋值的概念，也不存在命令。

## 1.4 命令式语言和函数式语言的求值顺序

在命令式语言中，命令执行的顺序非常关键。顺序不同，则极有可能导致结果不同，请看如下的交换操作：

```python
T := X; X := Y; Y := T
```
T依赖X，X依赖Y，Y又依赖T，是一个循环依赖，所以改变任意两个命令的顺序都会导致结果不同。例如
```python
X := Y; T := X; Y := T   结果是X赋值为Y
T := X; Y := T; X := Y   结果是Y赋值为X
```
当然，并不是改变顺序一定会导致结果不同。如果一条命令不和其他任何一条命令相互引用变量，交换它和另外一条命令的顺序是不会影响结果的，但是的命令一般都会相互引用变量，因为这是命令式语言起作用的关键啊。

在函数式语言中，函数求值并不会改变名值绑定，平级函数的求值顺序不会影响结果，因为平级函数之间不会相互影响。例如:
```python
Function F(X, Y, Z: Int): Int

Function A(P: Int): Int

Function B(Q: Int): Int

Function C(R: Int): Int

F(A(D), B(D), C(D))
```
A(D), B(D), C(D)这三个函数无论谁先求值都不会影响结果，因为他们并不会重新绑定D

当然函数式程序实际执行的时候，是有某种顺序的（无论哪种语言编写的程序都会以某种顺序执行），但是顺序不会影响最终结果。以后我们会看到，顺序中立是函数式语言的强大特性之一，在理论和实践中都有广泛应用。

## 1.5 命令式语言和函数式语言中的循环

先抛出问题：对一个长度为N的数组求和（下标从0开始）。步骤如下：
```python
Sum0 := A[0]
Sum1 := Sum1 + A[1]
Sum2 := Sum2 + A[2]
... ...
```
因为有N个元素，所以需要N条命令，每条命令都会引入一个新的Sum符号来表示求和结果。即需要10条命令，10个名。

在命令式语言中，因为名可以重新绑定，所以我们主需要一个Sum符号即可。也不需要10条命令，一条命令执行10次即可。如下:
```python
i := 0
Sum := 0
while (i < N) {
    Sum = Sum + A[i]
    i = i + 1
}
```
在函数式语言中，因为名只能绑定一次，所以我们要引入N个名才能完成任务。另外函数式语言是不存在命令串的，这种循环的任务只能用递归函数。
```python
Function SUM(A: Array[Int], i: Int, N: Int): Int {
    if (i >= N)
        Sum := 0
    else
        Sum := A[i] + SUM(A, i+1, N)
}

  SUM(A, 0, N)
= A[0] + SUM(A, 1, N)
= A[0] + A[1] + SUM(A, 2, N)
= A[0] + A[1] + ... + A[N-1] + SUM(A, N, N)
= A[0] + A[1] + ... + A[N-1] + 0
= A[0] + A[1] + ... + A[N-1]
```
每一次递归调用都重新引入了A, i, N这三个本地符号，屏蔽之前的符号；函数求值完毕后，刚刚新引入的符号就消失了，上一个函数的本地符号又能访问了。

## 1.6 函数式语言的数据结构

在命令式语言中，数组元素和结构体成员都能用赋值语句更新。但是函数式语言没有赋值的概念，数据结构的子结构是无法独立更新的，所以为了更新子结构，必须重新创建一个完整的数据结构。这就要求函数式语言的数据结构必须是完全__显式__的。

函数式语言不提供数组，因为缺少赋值导致它无法方便地访问数组元素，另外为了更新一个元素就重新创建整个数组也是不可接受的。函数式语言倾向提供递归的数据结构，如列表。递归的数据结构通常和嵌套函数调用采用相似的表示法，事实上，LISP的函数和数据结构采用相同的表示法。

显示的表示数据结构有不少好处。方便打印，我们无需为每个成员写特殊的打印方法，这在调试的时候会很有用。同样的，我们也不用为每个成员写特殊的序列化方法，这在IO操作时很有用。

函数式语言还有一个不同的地方，它没有全局变量。在命令式语言中，全局变量很常见，多个子过程不通过参数传递就能修改它们，即隐式传递。然后，函数式语言没有赋值操作，变量显示传递。所以函数式语言的函数参数一般比命令式语言的多，这样也有一个好处，数据流是显示的，容易跟踪。

## 1.7 函数即值

```python
Type OP_TYPE = (ADD, SUB, MULT, QUOT)

Function Sum(X: Int, Y: Int): Int = X + Y
Function Diff(X: Int, Y: Int): Int = X - Y
Function Times(X: Int, Y: Int): Int = X * Y
Function Divide(X: Int, Y: Int): Int = X / Y

Function Arith(op: OP_TYPE): Function = {
    CASE op OF
    ADD  => Sum
    SUB  => Diff
    MULT => Times
    QUOT => Divide
}

Arith(ADD)  求值得 Sum
Arith(SUB)  求值得 Diff
Arith(MULT) 求值得 Times
Arith(QUOT) 求值得 Divide

Arith(ADD)(3, 4) 求值得 3 + 4，即7
```
